<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>spiralcraft.builder</title>
</head>
<body alink="#000099" bgcolor="#ffffff" link="#000099" text="#000000"
 vlink="#990099">
<h1>Spiralcraft</h1>
<hr size="2" width="100%">
<h2>spiralcraft.builder package</h2>
The spiralcraft.builder package is an inversion-of-control (IoC)
framework which helps assemble independently developed components into
cohesive applications. It uses a declarative mechanism to describe the
interdependencies, configuration and lifecycles of the components which
make up an application, freeing the components themselves from being
dependent on the context in which they are used.<br>
<br>
Spiralcraft.builder assembles components into units called Assemblies.
An Assembly is composed of a single instance of a Java component, its
configuration properties and other Assemblies on which the component
depends.<br>
<br>
All Assemblies are defined by Assembly Classes, in much the same
fashion as Java Objects are defined by Java Classes. The primary
purpose of an Assembly Class is to associate the Java Bean properties
of a single Java Class with configuration values, expressions, and/or
other Assembly Classes, defining a compositional unit of an
application. Once an Assembly Class is loaded into memory, many
Assemblies can be instantiated efficiently.<br>
<br>
Assembly Classes can subclass other Assembly Classes. Since Assembly
Classes define units of application composition, to subclass an
Assembly Class is to further specialize and extend a composition for a
given context by including or overriding dependencies, configuration
values and other Assembly Classes.<br>
<br>
Assembly Classes are defined using a compact XML syntax. An XML
document contains a tree of Assembly Class definitions, which reference
external entities such as Java classes and assorted other XML Assembly
Class definitions. To maintain order within this modular approach, the
XML tag and file naming semantics are closely associated with the Java
semantics for class and package naming, and source code and class file
resolution.<br>
<br>
<h3>XML Assembly Class Definitions</h3>
XML Assembly Class definition files contain one or more Assembly Class
Definitions: a root definition, and possible one or more definitions
associated with the Java bean properties of a parent definition. Tags
are used either to identify an Assembly Class definition, or to define
a specific property within an Assembly Class definition. In the former
case, tag names identify the Java Class or base Assembly Class from
which a given Assembly Class is derived, and the element contains a set
of property definitions. In the latter case, tag names identify the
bean property being defined and the element can contains a value or one
or more Assembly Class definitions to inject into the property at
configuration time.<br>
<br>
<h3>Name Resolution</h3>
All Assembly Classes are defined with respect to their base Java class
or Assembly Class, specified in the form of a URI with no filename
extension. For example <span style="font-family: monospace;">&lt;auto:Car
xmlns:auto="class:/com/myco/automotive"&gt;</span> translates to the URI
"<span style="font-family: monospace;">class:/com/myco/automotive/Car</span>".
This URI is constructed using the XML namespace name and the tag name.
If a resource of the pattern &lt;URI&gt;.assembly.xml exists, it will
be used as the base Assembly Class for this Assembly. Otherwise, the
URI will be converted to a class name according to the Java language
convention (eg. "<span style="font-family: monospace;">com.myco.automotive.Car</span>").<br>
<br>
<h3>Expressions in property specifiers</h3>
spiralcraft.lang expressions can be used within property specifiers to
inject values defined elsewhere. A tree of Assembly Class definitions
define a hierarchical context for the resolution of the "focus"
specifier in the spiralcraft.lang package. For instance, if an ancestor
of an Assembly Class is named "<span style="font-family: monospace;">CacheConfiguration</span>",
the tag <span style="font-family: monospace;">&lt;timeToLive
expression="[CacheConfiguration].defaultTimeToLive"/&gt;</span> will
resolve a reference to the <span style="font-family: monospace;">CacheConfiguration</span>
Java object generated by that Assembly and inject the value of its <span
 style="font-family: monospace;">defaultTimeToLive</span> property into
the <span style="font-family: monospace;">timeToLive </span>property
of the Java object generated by the Assembly Class.<br>
<br>
<h3>Inheritance</h3>
Assembly Classes can extend one another via an inheritance mechanism.
Assembly Classes that do not extend another Assembly Class 'extend' the
Java class resolved from the tag name. The inheritance mechanism
permits application construction using multiple layers of abstraction,
customization and composition. See the paragraph on Name Resolution for
an explanation of how the tag names in Assembly Class definitions
specify inheritance.<br>
<br>
When an Assembly Class (the extended Assembly Class) inherits from
another Assembly Class (the base Assembly Class), the extended
AssemblyClass inherits the compositional structure defined in the base
AssemblyClass. If a property value is defined in both the base Assembly
Class and the extended Assembly Class, if the property is a singular
type, the definition in the extended Assembly Class overrides the
definition in the base Assembly Class. If the property value is an
aggregate type (an Array or Collection), the definition in the extended
Assembly Class is appended to the definition in the base Assembly Class.<br>
<br>
When inheriting from a base AssemblyClass, it is somtimes useful to
define property values for nested Assemblies. This is accomplished by
chaining the property names together with a '.'. The following example
assumes that Foo contains a Bar object in its fooProp property, and
that the Bar object has a barProp property that is set to the specified
value.<br>
<br>
<span style="font-family: monospace;">&lt;Foo&gt;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;
&lt;fooProp.barProp&gt;baz&lt;/fooProp.barProp&gt;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&lt;/Foo&gt;</span><br
 style="font-family: monospace;">
<h3>Constructor Based Instantiation</h3>
When spiralcraft.builder is used to instantiate application components
that have Java Beans properties, it normally uses a required zero
argument constructor to instantiate the object. Spiralcraft.builder
also supports a shorthand way of instantiating objects with a 1
argument constructor that accepts a String. This method is commonly
used for instantiating simple immutable objects such as Strings,
DateFormats, etc. <br>
<h4>Example of Constructor Based Instantiation</h4>
File: ShipsDoctor.assembly.xml<br>
<br>
<span style="font-family: monospace;">&lt;Person&gt;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; &lt;name&gt;Leonard
McCoy&lt;/name&gt;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; &lt;nicknames&gt;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
&lt;String&gt;Doc&lt;/String&gt;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
&lt;String&gt;Bones&lt;/String&gt;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
&lt;String&gt;McCoy&lt;/String&gt;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; &lt;/nicknames&gt;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&lt;/Person&gt;</span><br>
<br>
File: TimeFormat.assembly.xml<br>
<br>
<span style="font-family: monospace;">&lt;SimpleDateFormat&gt;hh:mm:ss&lt;/SimpleDateFormat&gt;</span><br>
<br>
<h3>API</h3>
The following code instantiates a Java object model from an Assembly
Class definition.<br>
<br>
<span style="font-family: monospace;">import
spiralcraft.builder.AssemblyLoader;<br>
import spiralcraft.builder.AssemblyClass;<br>
import spiralcraft.buolder.Assembly;<br>
<br>
import java.net.URI;<br>
<br>
import com.myco.automotive.Car;<br>
<br>
URI uri=URI.create("class:/com/myco/automotive/Car.assembly.xml");<br>
<br>
// Obtain the default instance of the AssemblyLoader<br>
AssemblyLoader loader = AssemblyLoader.getInstance();<br>
<br>
// Load the Assembly Class<br>
AssemblyClass assemblyClass =&nbsp; loader.findAssemblyDefinition(uri);<br>
<br>
// Instantiate the assembly- the null parameter indicates that<br>
//&nbsp;&nbsp; this assembly is stand-alone (not contained within a
parent<br>
//&nbsp;&nbsp; assembly).<br>
Assembly assembly=assemblyClass.newInstance(null);<br>
<br>
// Return a fully configured Car<br>
Car car=(Car) assembly.getObject();<br>
</span><br>
<h3>Examples</h3>
The following examples illustrate the basic features of the
spiralcraft.builder framework using a automobile analogy.. <br>
<h4>Example 1.</h4>
<tt>File: com/myco/automotive/Car.assembly.xml<br>
<br>
&lt;auto:Car<br>
&nbsp; xmlns:auto="class:/com/myco/automotive"<br>
/&gt;<br>
</tt><br>
In this trivial example, an instance of class com.myco.automotive.Car
will be created.
<h4>Example 2.</h4>
<tt>File: com/myco/automotive/CarModelOne.assembly.xml<br>
<br>
&lt;auto:Car<br>
&nbsp; xmlns:auto="class:/com/myco/automotive"<br>
&nbsp; &gt;<br>
&nbsp; &lt;color&gt;blue&lt;/color&gt;<br>
&nbsp; &lt;engine&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;auto:SixCylinderEngine&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;capacityLiters&gt;4.2&lt;/capacityLiters&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;/auto:SixCylinderEngine&gt;<br>
&nbsp; &lt;/engine&gt;<br>
&lt;/auto:Car&gt;<br>
</tt><tt></tt><br>
In this example, an assembly called CarModelOne is defined. An instance
of class com.myco.automotive.Car will be created, and the
setColor(String color) method will be called with a String parameter
"blue". An instance of com.myco.automotive.SixCylinderEngine (which
implements the com.myco.automotive.Engine interface) will be created
and injected into the setEngine(com.myco.automotive.Engine) method. The
setCapacityLiters(float liters) method on SixCylinderEngine will
receive a value of 4.2.<br>
<h4>Example 3.</h4>
<tt>File: com/myco/automotive/CustomCar.assembly.xml<br>
<br>
&lt;auto:CarModelOne<br>
&nbsp; xmlns:auto="class:/com/myco/automotive"<br>
&nbsp; &gt;<br>
&nbsp; &lt;color&gt;red&lt;/color&gt;<br>
&nbsp; &lt;engine.capacityLiters&gt;5.0&lt;/engine.capacityLiters&gt;<br>
&lt;/auto:CarModelOne&gt;</tt><br>
<br>
In this example, an assembly called CustomCar is defined. It is based
on CarModelOne, but the color is changed to red and the capacity of the
engine is changed to 5.0 liters. The dot notation in the
"engine.capacityLiters" property provides access to a property of the
engine subassembly.<br>
<br>
<h4>Example 4.</h4>
<tt>File: com/myco/automotive/MyFleet.assembly.xml<br>
<br>
&lt;auto:Fleet<br>
&nbsp; xmlns:auto="class:/com/myco/automotive"<br>
&nbsp; &gt;<br>
&nbsp; &lt;owner&gt;me&lt;/owner&gt;<br>
&nbsp; &lt;cars&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;auto:CarModelOne&gt;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &lt;vin&gt;abc&lt;/vin&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;owner
expression="[Fleet].owner"/&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;/auto:CarModelOne&gt;<br>
</tt><tt>&nbsp;&nbsp;&nbsp; &lt;auto:CarModelOne&gt;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &lt;vin&gt;def&lt;/vin&gt;<br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;owner
expression="[Fleet].owner"/&gt;<br>
</tt><tt>
&nbsp;&nbsp;&nbsp; &lt;/auto:CarModelOne&gt;<br>
</tt><tt>&nbsp;&nbsp;&nbsp; &lt;auto:CustomCar&gt;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &lt;vin&gt;ghi&lt;/vin&gt;<br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;owner
expression="[Fleet].owner"/&gt;<br>
</tt><tt>
&nbsp;&nbsp;&nbsp; &lt;/auto:CustomCar&gt;<br>
</tt><tt>&nbsp; &lt;/cars&gt;<br>
&lt;/auto:Fleet&gt;</tt><br>
<br>
In this example, an Fleet called MyFleet is created, with 2 distinct
instances of CarModelOne and one instance of a CustomCar. The owner
propery of all the cars is set to the owner of the Fleet via a
spiralcraft.lang expression. This expression indicates that within the
Fleet context (ie. "<span style="font-family: monospace;">[Fleet]</span>"),
the <span style="font-family: monospace;">owner</span> property is to
be bound to the Car.owner property.<br>
<br>
<h4>Example 5.</h4>
<tt>File: com/myco/automotive/MyExtendedFleet.assembly.xml<br>
<br>
&lt;auto:MyFleet<br>
&nbsp; xmlns:auto="class:/com/myco/automotive"<br>
&nbsp; &gt;<br>
&nbsp; &lt;cars&gt;<br>
</tt><tt>&nbsp;&nbsp;&nbsp; &lt;auto:CustomCar&gt;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &lt;vin&gt;jkl&lt;/vin&gt;<br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;owner
expression="[Fleet].owner"/&gt;<br>
</tt><tt>
&nbsp;&nbsp;&nbsp; &lt;/auto:CustomCar&gt;<br>
</tt><tt>&nbsp;&nbsp;&nbsp; &lt;auto:CustomCar&gt;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &lt;vin&gt;mno&lt;/vin&gt;<br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;owner
expression="[Fleet].owner"/&gt;<br>
</tt><tt>
&nbsp;&nbsp;&nbsp; &lt;/auto:CustomCar&gt;<br>
</tt><tt>&nbsp; &lt;/cars&gt;<br>
&lt;/auto:Fleet&gt;</tt><br>
<br>
In this example, MyExtendedFleet is defined, which adds two custom cars
to MyFleet. When aggregate properties (arrays or collections) are
specified in both a base assembly and an extended assembly, the values
in the extended assembly are added to the values in the base assembly,
and the property is injected with an array or collection containing the
combined list.<br>
<br>
<br>
<br>
<br>
<br>
</body>
</html>
